
"""
The SNMPInterfacePoll is designed for collecting interface data from
remote SNMP-enabled devices such as routers and switches using SNMP IF_MIB

#### Installation

The SNMPInterfacePoll.py module should be installed into your Diamond
installation collectors directory. This directory is defined
in diamond.cfg under the *collectors_path* directive. This defaults to
*/usr/lib/diamond/collectors/* on Ubuntu.

The SNMPInterfacePoll.cfg file should be installed into your diamond
installation config directory. This directory is defined
in diamond.cfg under the *collectors_config_path* directive. This defaults to
*/etc/diamond/* on Ubuntu.

The SNMPInterfacePoll relies on oids.lst, which is generated by another
collector called SNMPInterfaceDiscovery. The SNMPInterfaceDiscovery collector
queirres interface trees for active interfaces and writes the graphite metric
paths and the corrosponding device OIDs into the flat file to querry.

#### Configuration

### Dependencies

 * pysmnp

"""
import os
import sys
import re
import time
import threading
import diamond.convertor
from diamond.metric import Metric
from snmp import SNMPCollector as parent_SNMPCollector
from pysnmp.entity.rfc3413.oneliner import cmdgen
from pysnmp.proto import rfc1155, rfc1902, api
from pyasn1.codec.ber import encoder, decoder

sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)),
                                'snmp'))
COUNTER_MAX_64BIT = 18446744073709551616

# --- hack to fix counters that may be returned as negative. 
# http://pysnmp.sourceforge.net/faq.html

def counterCloneHack(self, *args):
    if args and args[0] < 0:
        args = (0xffffffff+args[0]-1,) + args[1:]

    return self.__class__(*args)

rfc1155.Counter.clone = counterCloneHack
rfc1902.Counter32.clone = counterCloneHack
rfc1902.Counter64.clone = counterCloneHack

class SNMPInterfacePoll(parent_SNMPCollector):

    def get_default_config(self):
        """
        Override SNMPCollector.get_default_config method to provide
        default_config for the SNMPInterfacePoll
        """
        default_config = super(SNMPInterfacePoll,
                               self).get_default_config()
        default_config['path'] = 'interface'
        default_config['byte_unit'] = ['bit', 'byte']
        return default_config

    def publish_metrics(self, gaugesList, countersList, timestamp):

        for gaugeDesc in gaugesList:
            metricPath, metricValue = gaugeDesc
            metric = Metric(
                            metricPath, metricValue,
                            raw_value=None, timestamp=timestamp
                            )
            self.publish_metric(metric)

        for counterDesc in countersList:
            metricPath, metricValue = counterDesc
            if metricPath == 'ERROR:':
                self.log.info(MetricPath, MetricVale)
                continue
            if 'Octets' in metricPath:
                for unit in self.config['byte_unit']:
                    metricPathNewUnit = metricPath.replace('Octets', unit)
                    metricValueNewUnit = diamond.convertor.binary.convert(
                    value=metricValue,
                    oldUnit='byte',
                    newUnit=unit)
                    metric = Metric(
                            metricPathNewUnit,
                            self.derivative(
                                            metricPathNewUnit,
                                            metricValueNewUnit,
                                            COUNTER_MAX_64BIT
                                            ),
                            raw_value=None,
                            timestamp=timestamp
                            )
                    self.publish_metric(metric)
            else:
            # Graphite's derivitive has no counter reset detection, so use the collector class method instead.
		self.log.info(metricPath, metricValue)
                try:
                  metric = Metric(metricPath,
                                  self.derivative(
                                        metricPath,
                                        metricValue,
                                        COUNTER_MAX_64BIT
                                        ),
                                  raw_value=None,
                                  timestamp=timestamp
                                  )
                  self.publish_metric(metric)
                except:
                  self.log.info('ERROR collecting ' + str(metricPath))
                  pass

    def parse_oids_file(self, oidFilename):
        allOids = []
        allHosts = []
        oidsPerHost = []

        # Stuff entire flat-file into a list.
        try:
            with open(oidFilename) as f:
                allOids = f.read().splitlines()
        except IOError:
            self.log.info(oidFilename, "doesn't exist, wait for SNMPInterfaceDiscovery to run first.")
            # Return an empty list.
            return oidsPerHost

        # Parse out the hosts in our list.
        for oidDesc in allOids:
            oidType, curHost, community, oid, metricPath = oidDesc.split(',', 5)
            allHosts.append(curHost)
        
        # Put the unique hosts in a set to key smaller lists off of below..
        uniqueHosts = set(allHosts)
        
        # Cycle through the oid flat file entries and create a big list of smaller lists contaning oids to poll,
        # one smaller list for each unique host.

        for uniqueHost in uniqueHosts:
            templist = []
            for oidDesc in allOids:
                if uniqueHost in oidDesc:
                    templist.append(oidDesc)
            oidsPerHost.append(templist)


        return oidsPerHost

    def collect_snmp(self, device, host, port, community):
        """
        Open and process the OID flat file, then poll for SNMP data from each
        device in a different thread. Steps:
        - Stuff the flat file into list
        - Determine unique hosts repersented in that list
        - Define a set contaning those unique hosts
        - Create a list of lists with oid descriptions, unique to ecah host
        - Fire off one thread per list to querry devices
        - Publish aggreagated metric lists created by threads.
        """
                
        gaugesToPublish = []
        countersToPublish = []

        def fetch_oids(oidList):
            # Use base pysnmp methods for more speed.

            # One long living PySNMP command generator for the loop below.
            cmdGen = cmdgen.CommandGenerator()

            for oidDesc in oidList:
                oidType, curHost, community, oid, metricPath = oidDesc.split(',', 5)
                
                errorIndication, errorStatus, errorIndex, varBinds = cmdGen.getCmd(
                cmdgen.CommunityData(community),
                cmdgen.UdpTransportTarget((curHost, 161)),
                oid
                )
                if errorIndication:
                    # Just append some error information to the counter publish list. 
                    # for logging latter.
                    countersToPublish.append(('ERROR:'), (curHost + oid))
                    continue
                else:
                    for name, val in varBinds:
                        if oidType == 'C':
                            countersToPublish.append((metricPath, val))
                        else:
                            gaugesToPublish.append((metricPath, val))
      
        
        oidFilename = '/etc/diamond/collectors/SNMPInterfacePoll.d/oids.lst'
        oidsPerHost = self.parse_oids_file(oidFilename)

        self.log.info('Collecting SNMP interface statistics from all devices..')
        
        gaugesToPublish = []
        countersToPublish = []
        threads = []

        # Create one thread per host oidlist. 
        for anOidList in oidsPerHost:
            t = threading.Thread(target=fetch_oids, args=(anOidList,))
            threads.append(t)
            t.start()

        for thread in threads:
            thread.join()

        # Loop through the lists generated by the threaded methods above, and publish each metric.
        self.publish_metrics(gaugesToPublish, countersToPublish, time.time())
        self.log.info('Done publishing SNMP metrics for all devices.')

    
